---
title: Dremio
description: A Reference on Dremio
---

### Dremio and its Architecture

**Dremio** is an open-source data lake engine that provides self-service data analytics for data lakes and data warehouses. It simplifies the process of accessing, querying, and analyzing data stored in various data sources, including data lakes, databases, cloud storage, and more. Dremio's architecture is designed to provide high performance, scalability, and ease of use.

#### Dremio Architecture

Dremio's architecture is built around the concept of a Data Lake Engine, which enables users to interact with data lakes seamlessly. The core components of Dremio's architecture include:

1. **Coordinator**: The Coordinator is the brain of the Dremio cluster. It manages query optimization, query planning, and coordination across the cluster. The Coordinator translates SQL queries into a directed acyclic graph (DAG) of tasks and distributes them to the relevant execution engines.

2. **Executor**: Executors are responsible for executing tasks generated by the Coordinator. Each Executor is responsible for a subset of tasks and can run on different nodes within the Dremio cluster. Executors interact with data sources, cache query results, and return data to the Coordinator.

3. **Metadata Cache**: Dremio maintains a Metadata Cache that stores metadata information about the data sources, schema, and statistics. This cache optimizes query planning by reducing the need to access metadata from data sources repeatedly.

4. **Acceleration**: Dremio provides a powerful acceleration engine that uses techniques like Reflections and Arrow Caching to accelerate query execution. Reflections are materialized views that optimize queries by precomputing and caching results.

5. **SQL Parsing and Planning**: Dremio includes a SQL Parser and Planner responsible for parsing SQL queries, optimizing query plans, and generating execution plans. It uses cost-based optimization techniques to optimize query performance.

6. **Connectors**: Dremio's architecture supports a wide range of connectors for various data sources. These connectors allow Dremio to interact with data stored in relational databases, NoSQL databases, data lakes, cloud storage platforms, and more.

7. **Web UI and Interfaces**: Dremio provides a web-based user interface (UI) that allows users to explore and analyze data visually. It also offers REST APIs and JDBC/ODBC connectors for programmatic access.

#### How Dremio Works

Dremio simplifies data access and analytics with the following workflow:

1. **Data Source Registration**: Users configure and register data sources within Dremio, specifying the necessary connection details.

2. **SQL Queries**: Users write SQL queries in Dremio's UI or through external applications using JDBC or ODBC drivers.

3. **Query Optimization**: Dremio's Coordinator optimizes SQL queries by generating efficient execution plans.

4. **Parallel Execution**: Queries are parallelized and distributed across Executor nodes for execution.

5. **Data Source Access**: Executors access data from the registered data sources, including data lakes, cloud storage, or databases.

6. **Caching and Reflections**: Dremio's acceleration engine leverages caching and reflections to improve query performance by reusing previously computed results.

7. **Query Results**: The query results are returned to the user through the Dremio UI or external applications.

#### Benefits of Dremio

Dremio offers several benefits, including:

- **Self-Service Data Access**: Users can explore and analyze data without depending on IT or data engineering teams.

- **High Performance**: Dremio optimizes query execution for faster results, even on large datasets.

- **Data Lake Unification**: Dremio provides a unified view of data across data lakes and data warehouses.

- **SQL Compatibility**: Users can leverage their SQL skills to query and analyze data.

- **Scalability**: Dremio clusters can scale horizontally to handle increasing data workloads.

- **Security**: Dremio includes security features like authentication, authorization, and encryption to protect data.

Dremio's architecture and capabilities make it a valuable tool for organizations looking to harness the power of their data lakes and improve data analytics.

### Use Cases for Dremio

Dremio is a versatile data lake engine that serves a variety of use cases across different industries. Its ability to simplify data access, optimize query performance, and provide a unified view of data makes it a valuable tool for organizations. Here are some common use cases for Dremio:

#### 1. Self-Service Data Exploration

**Use Case**: Business analysts, data scientists, and non-technical users often need to explore and analyze data without the assistance of IT or data engineering teams. Dremio's self-service data exploration capabilities allow users to easily query and visualize data, empowering them to make data-driven decisions.

**Benefits**:
- Reduced reliance on IT teams for ad-hoc queries.
- Faster insights into data for informed decision-making.
- Improved collaboration between business and technical teams.

#### 2. Data Lake Analytics

**Use Case**: Organizations store vast amounts of data in data lakes like Amazon S3, Azure Data Lake Storage, or Hadoop HDFS. Dremio simplifies data lake analytics by providing a SQL-based interface to query and analyze data directly from data lakes without the need for ETL or data movement.

**Benefits**:
- Elimination of data silos and data movement costs.
- Real-time access to data for analytics.
- Cost-effective data lake utilization.

#### 3. Data Virtualization

**Use Case**: Enterprises often have data scattered across multiple data sources, including databases, data warehouses, and cloud platforms. Dremio acts as a data virtualization layer, allowing users to query and join data from various sources seamlessly.

**Benefits**:
- Unified view of data from diverse sources.
- Reduced data duplication and storage costs.
- Faster data access without complex integrations.

#### 4. Accelerated BI and Reporting

**Use Case**: Business intelligence (BI) tools and reporting platforms require fast access to data. Dremio's acceleration engine, including reflections and caching, optimizes query performance for BI tools, enabling interactive and real-time reporting.

**Benefits**:
- Improved BI tool performance.
- Faster generation of reports and dashboards.
- Enhanced user experience for data-driven reporting.

#### 5. DataOps and Data Engineering

**Use Case**: Data engineers and DataOps teams use Dremio to simplify data pipeline development and testing. Dremio's ability to preview data and transform it in real time helps streamline ETL processes.

**Benefits**:
- Accelerated data pipeline development.
- Reduced errors through data validation and transformation.
- Faster iteration during development and testing.

#### 6. Data Governance and Security

**Use Case**: Organizations need to enforce data governance policies, access control, and auditing. Dremio provides authentication, authorization, and encryption features to ensure data security and compliance with regulatory requirements.

**Benefits**:
- Data security and compliance with regulations (e.g., GDPR, HIPAA).
- Fine-grained access control for sensitive data.
- Audit trails for data access and changes.

#### 7. Cloud Data Lake Migration

**Use Case**: Migrating on-premises data warehouses or legacy systems to cloud-based data lakes is a common initiative. Dremio simplifies the migration process by enabling query access to both on-premises and cloud data.

**Benefits**:
- Seamless transition to cloud data lakes.
- Minimal disruption to existing data processes.
- Reduced migration complexity.

#### 8. IoT and Log Analytics

**Use Case**: Organizations with large volumes of IoT device data or logs can use Dremio to query and analyze this data in real time. Dremio's acceleration capabilities ensure fast insights into streaming data.

**Benefits**:
- Real-time monitoring and analysis of IoT data.
- Quick identification of anomalies or patterns.
- Improved operational efficiency.

Dremio's flexibility and capabilities make it a versatile solution for a wide range of data-related use cases, helping organizations unlock the full potential of their data assets.

### How Dremio Delivers Performance

Dremio is designed to provide high performance for data access, query execution, and analytics. Its architecture and various optimization techniques contribute to its ability to deliver exceptional query performance. Here's how Dremio achieves this:

#### 1. Distributed Query Execution

Dremio distributes query processing tasks across multiple executor nodes in a cluster. This parallelism allows for the efficient use of computing resources and speeds up query execution. Queries are divided into smaller tasks, executed in parallel, and results are combined for a faster response.

#### 2. Query Optimization

Dremio employs advanced query optimization techniques to generate efficient query execution plans. It uses cost-based optimization, statistics, and intelligent caching to choose the most optimal execution path for a query. This leads to reduced query execution times and resource utilization.

#### 3. Caching and Reflections

Dremio's acceleration engine includes two key features: caching and reflections. Caching stores the results of frequently executed queries in memory, making subsequent executions of the same query significantly faster. Reflections are materialized views that precompute and cache aggregations and joins, further improving query performance.

#### 4. Data Pruning and Projection

Dremio performs data pruning and projection to minimize the amount of data read from underlying data sources. It intelligently skips unnecessary data based on query predicates and projections, reducing I/O and improving query speed.

#### 5. Columnar Storage

Dremio uses Apache Arrow as its internal data representation format, which is a columnar storage format. Columnar storage reduces the amount of data that needs to be read from disk, enhances compression, and enables vectorized processing, resulting in faster query performance.

#### 6. In-Memory Processing

Dremio utilizes in-memory processing whenever possible. By keeping frequently accessed data in memory, Dremio reduces disk I/O and ensures that queries are processed at high speed. It leverages memory for both caching and intermediate query results.

#### 7. Vectorized Execution

Dremio employs vectorized query execution, which operates on batches of data rather than individual rows. Vectorized processing improves CPU cache utilization and reduces function call overhead, resulting in efficient query processing.

#### 8. Cost-Based Optimization

Dremio's cost-based optimization considers factors such as data location, data distribution, and available resources when planning query execution. This approach ensures that resources are allocated optimally for each query, minimizing query latency.

#### 9. Adaptive Query Execution

Dremio includes adaptive query execution capabilities that dynamically adjust query execution plans based on runtime statistics. This adaptation helps handle varying workloads and changing data distributions effectively.

#### 10. Scale-Out Architecture

Dremio's architecture allows for easy horizontal scaling by adding more executor nodes to the cluster. This scalability ensures that Dremio can handle increasing workloads while maintaining performance.

#### 11. Distributed Joins and Aggregations

Dremio can perform distributed joins and aggregations across multiple data sources, reducing data movement and improving performance. It leverages pushdown capabilities to execute operations closer to the data source whenever possible.

#### 12. Advanced Indexing

Dremio supports advanced indexing techniques that accelerate data access, especially in scenarios where indexing is appropriate. Indexes help speed up data retrieval for specific queries.

Dremio's focus on performance optimization and its ability to harness distributed computing resources make it an ideal choice for organizations that require fast and efficient data access, analysis, and reporting.

# Getting Started with Dremio Cloud

This guide will walk you through the steps to get started with Dremio Cloud, including creating a Sonar project, setting up an Iceberg table, and optimizing queries with data reflections.

- [If you first want to try Dremio on your laptop, follow this tutorial](https://www.dremio.com/blog/intro-to-dremio-nessie-and-apache-iceberg-on-your-laptop/)

## Prerequisites

Before you begin, make sure you have signed up for Dremio Cloud and have met the prerequisites for configuring a Sonar project. Once you have signed up, you will be logged into your organization and directed to your organization homepage.

Now, let's proceed to add a Sonar project.

## Step 1: Add a Sonar Project

After signing up for Dremio Cloud, follow these steps to create your first Sonar project:

1. On your organization homepage, locate the "Sonar" card and click "Add Sonar Project."

2. In the "Add Sonar Project" dialog, specify a name for your project under "Project name." You can change the name later if needed.

3. Choose a name for the Arctic catalog under "Arctic catalog name." Note that this name cannot be changed once the catalog is created.

4. Select the AWS Region where compute resources and the project store will be created. Refer to the list of supported regions for options.

5. Optionally, add one or more AWS tags for identifying compute resources in your AWS account.

6. Click "Next" to proceed with the configuration.

7. Click "Launch CFT" to open the AWS Console in a new browser tab. The CloudFormation template will configure project resources. For manual resource creation, you can choose "Create project manually."

8. In the AWS Console's "Quick create stack" page, specify a unique "Stack name" for your AWS account (no underscores).

9. Select the VPC and subnets where compute resources will be created.

10. The "Project Store" field displays a generated name for the S3 bucket serving as the metadata store. You can specify a different unique name if desired.

11. Choose the encryption type for the project store, with options like SSE-S3, SSE-KMS (AWS Managed Key), or SSE-KMS (Customer Managed Key). If selecting the latter, provide the KMS Key ARN.

12. Confirm acknowledgment that AWS CloudFormation may create IAM resources.

13. Click "Create stack," and wait for approximately five minutes while the required storage and compute resources are created.

## Step 2: Create an Iceberg Table

In this step, you will work with the NYC-taxi-trips.csv file (containing 330+ million rows) stored in an Amazon S3 bucket. Follow these steps to create an Iceberg table:

**Create a Folder**

1. Click the SQL Runner icon in the side navigation bar.

2. Copy and paste the SQL command provided below, replacing "catalog_name" with your catalog's name. Click "Run."

```sql
CREATE FOLDER "catalog_name"."my_folder";
```

### Create a Table

Click the SQL Runner icon again.

Copy and paste the SQL command below and click "Run" to create a table in your catalog:

```sql
CREATE TABLE "catalog_name"."my_folder"."nyc_trips" (
  pickup_datetime TIMESTAMP,
  passenger_count INT,
  trip_distance_mi FLOAT,
  fare_amount FLOAT,
  tip_amount FLOAT,
  total_amount FLOAT
);
```

### Populate the Table with Data

To populate the "nyc_trips" table with sample data, run the following SQL command:

```sql
COPY INTO "catalog_name"."my_folder"."nyc_trips"
FROM '@Samples/samples.dremio.com/' FILES('NYC-taxi-trips.csv');
```

### Query the Table

You can now query the populated data using the following SQL command:

```sql
SELECT *
FROM "catalog_name"."my_folder"."nyc_trips";
```

## Step 3: Accelerate Queries with a Reflection
To optimize queries and achieve sub-second response times on a table with 330+ million rows, you can create a data reflection. Data reflections use various techniques to optimize data close to Dremio Sonar's query engine. Here's how to create an aggregation reflection:

### Run the following SQL in the SQL Runner:

```sql
ALTER TABLE "catalog_name"."my_folder"."nyc_trips"
CREATE AGGREGATE REFLECTION "taxi_reflection"
USING DIMENSIONS ("pickup_datetime")
MEASURES (
  passenger_count,
  trip_distance_mi,
  fare_amount,
  tip_amount,
  total_amount
);
```

The reflection is created in just a few seconds. It will accelerate queries on the "nyc_trips" table and any views built on it.

## Step 4: Add Dataset Info to Enhance Discoverability
To help users understand and work with the dataset, you can add a markdown description and label. Follow these steps:

1. Browse to the Datasets page and click on "my_folder" in the upper left corner.

1. Hover over the "nyc_trips" table and click the "Edit settings" icon on the right.

1. In the "Details" tab, add a label (e.g., "public-data") to identify the dataset.

1. In the "Wiki" section, edit the wiki to provide a markdown description of the table, including examples, usage notes, and a point of contact for questions.

1. Now, users can easily understand and query the "my_folder.nyc_trips" table you created.

## Wrap-up and Next Steps
In just a few steps, you've created a project, set up an Iceberg table, accelerated queries with reflections, and enhanced dataset discoverability. Here are some key takeaways:

You can quickly create and populate an Iceberg table in Dremio.

Accelerate your queries using data reflections.
Improve dataset discoverability with labels and markdown descriptions.

### Clean Up (Optional)

If you want to remove the objects created in this tutorial, run the following SQL commands from the SQL Runner:

```sql
-- Drop the table that you created
DROP TABLE "catalog_name"."my_folder"."nyc_trips" AT BRANCH main;
```
